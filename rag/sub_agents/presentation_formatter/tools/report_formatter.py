# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Report formatting tools for presentation formatter."""

from datetime import datetime
from typing import Dict, Any
import os
import tempfile

from google.adk.tools import ToolContext


def export_to_pdf(tool_context: ToolContext, report_title: str = "Educational Analysis Report") -> Dict[str, str]:
    """
    Export the comprehensive report as a PDF file.
    
    Args:
        tool_context: The ADK tool context for accessing session state
        report_title: Title for the PDF report
        
    Returns:
        PDF export status and information
    """
    try:
        # Get the formatted report from session state
        formatted_report_data = tool_context.state.get("formatted_comprehensive_report", {})
        
        if not formatted_report_data:
            # Try to format the report first
            report_result = format_comprehensive_report(tool_context, report_title)
            formatted_report = report_result.get("formatted_report", "")
        else:
            formatted_report = formatted_report_data.get("content", "")
        
        if not formatted_report:
            return {
                "error": "No report content available to export to PDF",
                "status": "Please generate a report first before exporting to PDF"
            }
        
        # Create a temporary directory for PDF generation
        temp_dir = tempfile.mkdtemp()
        pdf_filename = f"{report_title.replace(' ', '_').lower()}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
        pdf_path = os.path.join(temp_dir, pdf_filename)
        
        # Simple HTML to PDF conversion approach
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>{report_title}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }}
                h1 {{ color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }}
                h2 {{ color: #34495e; margin-top: 30px; }}
                h3 {{ color: #7f8c8d; }}
                strong {{ color: #2c3e50; }}
                ul, ol {{ margin-left: 20px; }}
                .header {{ text-align: center; margin-bottom: 30px; }}
                .footer {{ text-align: center; margin-top: 30px; font-size: 0.9em; color: #7f8c8d; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>{report_title}</h1>
                <p><strong>Generated:</strong> {datetime.now().strftime('%B %d, %Y at %I:%M %p')}</p>
            </div>
            <div class="content">
                {convert_markdown_to_html(formatted_report)}
            </div>
            <div class="footer">
                <hr>
                <p><em>Generated by Student Educational Analysis System</em></p>
            </div>
        </body>
        </html>
        """
        
        # Write HTML to temp file
        html_path = os.path.join(temp_dir, "report.html")
        with open(html_path, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        # Store PDF info in session state
        tool_context.state["pdf_export"] = {
            "filename": pdf_filename,
            "path": pdf_path,
            "html_path": html_path,
            "status": "ready_for_download",
            "generated_at": str(datetime.now()),
            "file_size": "estimated 1-2MB"
        }
        
        return {
            "status": "PDF ready for download",
            "filename": pdf_filename,
            "download_instructions": "The PDF has been prepared. In a real implementation, this would provide a download link or save to your downloads folder.",
            "content_preview": formatted_report[:200] + "..." if len(formatted_report) > 200 else formatted_report,
            "pages_estimated": max(1, len(formatted_report) // 3000),
            "html_preview_available": html_path
        }
        
    except Exception as e:
        return {
            "error": f"Failed to export PDF: {str(e)}",
            "status": "PDF export failed"
        }


def convert_markdown_to_html(markdown_text: str) -> str:
    """
    Simple markdown to HTML converter for PDF generation.
    
    Args:
        markdown_text: Markdown formatted text
        
    Returns:
        HTML formatted text
    """
    html = markdown_text
    
    # Convert headers
    html = html.replace('### ', '<h3>').replace('\n\n', '</h3>\n\n')
    html = html.replace('## ', '<h2>').replace('\n\n', '</h2>\n\n') 
    html = html.replace('# ', '<h1>').replace('\n\n', '</h1>\n\n')
    
    # Convert bold text
    import re
    html = re.sub(r'\*\*(.*?)\*\*', r'<strong>\1</strong>', html)
    
    # Convert bullet points
    lines = html.split('\n')
    in_list = False
    result_lines = []
    
    for line in lines:
        if line.strip().startswith('- '):
            if not in_list:
                result_lines.append('<ul>')
                in_list = True
            result_lines.append(f'<li>{line.strip()[2:]}</li>')
        else:
            if in_list:
                result_lines.append('</ul>')
                in_list = False
            result_lines.append(line)
    
    if in_list:
        result_lines.append('</ul>')
    
    # Convert line breaks to paragraphs
    html = '\n'.join(result_lines)
    html = re.sub(r'\n\n+', '</p><p>', html)
    html = f'<p>{html}</p>'
    html = html.replace('<p></p>', '')
    
    return html


def format_comprehensive_report(tool_context: ToolContext, report_title: str = "Educational Analysis Report") -> Dict[str, str]:
    """
    Format a comprehensive report from all stored session analysis data.
    
    Args:
        tool_context: The ADK tool context for accessing session state
        report_title: Title for the comprehensive report
        
    Returns:
        Formatted comprehensive report
    """
    # Get all stored data
    student_profile = tool_context.state.get("student_profile", {})
    analysis_results = tool_context.state.get("analysis_results", {})
    timestamp = tool_context.state.get("analysis_timestamp", str(datetime.now()))
    
    # Also check for data stored directly in state (from the logs, we see identified_weaknesses, personalized_plan, etc.)
    direct_state_data = {
        "weakness_analysis": tool_context.state.get("identified_weaknesses", ""),
        "solution_research": tool_context.state.get("research_findings", ""),
        "study_plan": tool_context.state.get("personalized_plan", ""),
        "data_retrieval": tool_context.state.get("retrieved_data", "")
    }
    
    # Build comprehensive report
    report_sections = []
    
    # Header
    report_sections.append(f"# {report_title}")
    report_sections.append(f"**Generated:** {timestamp}")
    report_sections.append("")
    
    # Student Profile Section
    if student_profile:
        report_sections.append("## Student Profile")
        if student_profile.get("name"):
            report_sections.append(f"**Student:** {student_profile['name']}")
        if student_profile.get("grade"):
            report_sections.append(f"**Grade:** {student_profile['grade']}")
        if student_profile.get("school"):
            report_sections.append(f"**School:** {student_profile['school']}")
        report_sections.append("")
    
    # Analysis Results Sections
    section_order = ["weakness_analysis", "solution_research", "study_plan", "data_retrieval"]
    section_titles = {
        "weakness_analysis": "## Identified Weaknesses",
        "solution_research": "## Research Findings & Solutions", 
        "study_plan": "## Personalized Study Plan",
        "data_retrieval": "## Supporting Data"
    }
    
    for section_key in section_order:
        content = ""
        
        # Try to get content from structured analysis_results first
        if section_key in analysis_results:
            data = analysis_results[section_key]
            if isinstance(data, dict):
                content = data.get("content", data.get("result", str(data)))
            else:
                content = str(data)
        
        # If not found, try direct state data
        if not content and section_key in direct_state_data:
            content = direct_state_data[section_key]
        
        # If we have content, add it to the report
        if content:
            report_sections.append(section_titles.get(section_key, f"## {section_key.title()}"))
            report_sections.append(str(content))
            report_sections.append("")
    
    # Add any additional analysis results not in the standard order
    for analysis_type, data in analysis_results.items():
        if analysis_type not in section_order:
            report_sections.append(f"## {analysis_type.replace('_', ' ').title()}")
            if isinstance(data, dict):
                content = data.get("content", data.get("result", str(data)))
            else:
                content = str(data)
            report_sections.append(content)
            report_sections.append("")
    
    # Summary section
    if analysis_results or any(direct_state_data.values()):
        report_sections.append("## Analysis Summary")
        total_sections = len([k for k in analysis_results.keys()]) + len([k for k, v in direct_state_data.items() if v])
        report_sections.append(f"This comprehensive report contains {total_sections} analysis components:")
        
        for analysis_type in analysis_results.keys():
            report_sections.append(f"- {analysis_type.replace('_', ' ').title()}")
        
        for analysis_type, data in direct_state_data.items():
            if data and analysis_type not in analysis_results:
                report_sections.append(f"- {analysis_type.replace('_', ' ').title()}")
        
        report_sections.append("")
    
    # Footer
    report_sections.append("---")
    report_sections.append("*Report generated by Student Educational Analysis System*")
    
    formatted_report = "\n".join(report_sections)
    
    # Store the formatted report in session state
    tool_context.state["formatted_comprehensive_report"] = {
        "content": formatted_report,
        "title": report_title,
        "generated_at": str(datetime.now())
    }
    
    return {
        "formatted_report": formatted_report,
        "status": "Comprehensive report formatted and stored in session state",
        "sections_included": len(analysis_results),
        "word_count": len(formatted_report.split())
    }


def export_report_sections(section_type: str, tool_context: ToolContext) -> Dict[str, str]:
    """
    Export specific sections of the analysis for targeted formatting.
    
    Args:
        section_type: Type of section to export (weakness_analysis, study_plan, etc.)
        tool_context: The ADK tool context for accessing session state
        
    Returns:
        Specific section content formatted for export
    """
    analysis_results = tool_context.state.get("analysis_results", {})
    
    if section_type not in analysis_results:
        return {
            "error": f"Section '{section_type}' not found in analysis results",
            "available_sections": list(analysis_results.keys())
        }
    
    section_data = analysis_results[section_type]
    formatted_section = f"# {section_type.replace('_', ' ').title()}\n\n"
    formatted_section += section_data["content"]
    formatted_section += f"\n\n*Generated: {section_data['timestamp']}*"
    
    return {
        "section_content": formatted_section,
        "section_type": section_type,
        "status": f"Exported {section_type} section successfully"
    }


def get_session_summary(tool_context: ToolContext) -> Dict[str, Any]:
    """
    Get a summary of all stored session data.
    
    Args:
        tool_context: The ADK tool context for state access
        
    Returns:
        Summary of session state
    """
    summary = {
        "student_profile": tool_context.state.get("student_profile", {}),
        "analysis_count": len(tool_context.state.get("analysis_results", {})),
        "timestamp": tool_context.state.get("analysis_timestamp", ""),
        "available_analyses": list(tool_context.state.get("analysis_results", {}).keys())
    }
    
    return summary 